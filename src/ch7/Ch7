객체지향 II

상속 - 기존의 클래스를 재사용해 새로운 클래스를 작성하는 것. 새로 작성하는 클래스명 옆에 extends 기존 클래스명

- 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있는 장점이 있음
- 자손 클래스는 조상 클래스의 멤버들을 포함하게 됨
- 자손 클래스에서 멤버가 추가 되어도 조상 클래스에 영향x
- 생성자와 초기화 블럭은 상속 x
- 단일 상속만 허용
* 다중상속 처럼 구현하기 위해 상속과 포함관계를 둘다 사용해서 표현 가능

포함관계 - 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

클래스간의 관계 결정하기 - ‘~은 ~이다’ ( 상속 ) 와 ‘~은 ~을 가지고 있다’ (포함관계) 를 넣어 문장을 만들어 볼것


Object 클래스
- 모든 클래스의 조상 클래스
- toString() , equals() 와 같은 메서드를 정의하지 않고 사용할 수 있음


오버라이딩
- 조상 클래스로부터 상속받은 메서드를 자손의 클래스에 맞게 재정의 하는것

- 오버라이딩 조건

1. 메서드 이름이 같아야함
2. 매개변수가 같아야함
3. 반환타입이 같아야함

- 오버라이딩할 때 주의할 점

1. 접근제어자를 조상의 메서드보다 좁은 범위로 변경 x
2. 예외는 조상의 메서드보다 많이 선언할 수 없음
3. 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경 x



super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 멤버변수와 지역변수의 이름이 같을때 this로 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을때 super를 붙여 구별함
- super역시 static에 사용할 수 없음 ( static 은 인스턴스와 관련이 없기 때문 )


super() - 조상 클래스의 생성자

자손 클래스의 인스턴스를 생성하면 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성됨
조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출 되어야 함

* 모든 클래스의 생성자 첫 줄에 생성자 this() 또는 super() 를 호출 해야 함
* 조상 클래스의 멤버변수는 조상의 생성자에 의해서 초기화 되어야함


