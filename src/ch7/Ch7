객체지향 II

상속 - 기존의 클래스를 재사용해 새로운 클래스를 작성하는 것. 새로 작성하는 클래스명 옆에 extends 기존 클래스명

- 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있는 장점이 있음
- 자손 클래스는 조상 클래스의 멤버들을 포함하게 됨
- 자손 클래스에서 멤버가 추가 되어도 조상 클래스에 영향x
- 생성자와 초기화 블럭은 상속 x
- 단일 상속만 허용
* 다중상속 처럼 구현하기 위해 상속과 포함관계를 둘다 사용해서 표현 가능

포함관계 - 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것

클래스간의 관계 결정하기 - ‘~은 ~이다’ ( 상속 ) 와 ‘~은 ~을 가지고 있다’ (포함관계) 를 넣어 문장을 만들어 볼것


Object 클래스
- 모든 클래스의 조상 클래스
- toString() , equals() 와 같은 메서드를 정의하지 않고 사용할 수 있음


오버라이딩
- 조상 클래스로부터 상속받은 메서드를 자손의 클래스에 맞게 재정의 하는것

- 오버라이딩 조건

1. 메서드 이름이 같아야함
2. 매개변수가 같아야함
3. 반환타입이 같아야함

- 오버라이딩할 때 주의할 점

1. 접근제어자를 조상의 메서드보다 좁은 범위로 변경 x
2. 예외는 조상의 메서드보다 많이 선언할 수 없음
3. 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경 x



super

- 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수
- 멤버변수와 지역변수의 이름이 같을때 this로 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을때 super를 붙여 구별함
- super역시 static에 사용할 수 없음 ( static 은 인스턴스와 관련이 없기 때문 )


super() - 조상 클래스의 생성자

자손 클래스의 인스턴스를 생성하면 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성됨
조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에 자손 클래스의 생성자에서 조상 클래스의 생성자가 호출 되어야 함

* 모든 클래스의 생성자 첫 줄에 생성자 this() 또는 super() 를 호출 해야 함
* 조상 클래스의 멤버변수는 조상의 생성자에 의해서 초기화 되어야함



제어자 - 클래스 , 변수 , 메서드의 선언부에 사용되어 부가적인 의미를 부여. 접근제어자와 그 외의 제어자로 나뉨

- 접근 제어자 : public , protected , default , private
- 그 외 : static , final , abstract …

static - 클래스의 , 공통적인

- 인스턴스에 관계없이 같은 값을 갖음
- 인스턴스 생성 하지 않고도 사용 가능
- 인스턴스 메서드와 static 메서드 차이는 메서드 내에서 인스턴스 멤버를 사용하는가의 여부에 따라 다름


fianl - 변수에 사용하면 값을 변경할 수 없는 상수, 메서드에 사용되면 오버라이딩을 할 수 없게되고 클래스에 사용되면 상속 X


absract - 추상 메서드를 선언하는데 사용 
	 	 *추상메서드 : 메서드 선언부만 작성되고 수행 내용은 구현하지 않은 미완성 메서드


접근 제어자 - 멤버 또는 클래스에 사용되어 외부에서 접근하지 못하도록 제한하는 역할

private : 같은 클래스 내에서만 접근 가능
default : 같은 패키지 내에서만 접근 가능
protected : 같은 패키지 , 다른 패키지의 자손클래스에서 접근 가능
public : 접근 제한 X

생성자의 접근 제어자 - 생성자에 접근제어자를 부여해 외부에서 인스턴스 생성을 억제할 수 있음

다형성 - 여러가지 형태를 가질 수 있는 능력. 조상 클래스의 참조변수로 자손클래스를 다룰수 있는 것

- 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있음
- 자손타입의 참조변수로 조상타입의 인스턴스 참조 X —> 자손 타입의 참조변수가 사용할 수 있는 멤버의 개수가 조상타입보다 많을수 있기 때문

참조변수의 형변환

- 자손타입의 참조변수 —> 조상타입의 참조변수, 조상타입의 참조변수를 자손타입의 참조변수로 형변환 가능
- 자손타입 —> 조상타입 : 형변환 생략 가능 ( 업케스팅 )
- 조상타입 —> 자손타입 : 형변환 생략 불가 ( 다운케스팅 )

instaceof 연산자

- 주로 조건문에 사용. instanceof 의 왼쪽에는 참조변수, 오른쪽에는 타입 (클래스명 )이 피연산자로 위치
- 연산결과로 true가 나오면 형변환이 가능하다는 뜻



매개변수의 다형성

	Product 클래스를 상속받은 Tv, Computer, Audio 클래스가 있을때, Buyer 라는 클래스에 물건을 구입하는 메서드를 추가하려면
	각 제품을 구입하는 메서드를 작성해야 한다.
	하지만 메서드의 매개변수에 다형성을 적용하면 하나의 메서드로 간단히 처리할 수 있음


여러 종류의 객체를 배열로 다루기

- 조상타입의 참조변수 배열을 사용하면 공통의 조상을 가진 서로 다른 종류의 객체들을 배열로 묶어서 다룰 수 있음


추상 클래스 

- 미완성 메서드를 포함하고 있는 클래스
- 추상클래스로 인스턴스 생성 X
- 상속을 통해서 자손클래스에 의해서만 완성될 수 있음
- 각 클래스에서 공통적인 부분을 따로 뽑아 추상클래스로 만듦

추상 메서드 

- 선언부만 작성하고 구현부는 작성하지 않는 미완성 메서드
- 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 선언문만 작성
- 추상클래스를 상속받는 자손클래스는 오버라이딩을 통해 추상 메서드를 모두 구현해야함
- 상속받은 추상메서드 중 하나다로 구현하지 않으면 자손 클래스 역시 추상클래스로 지정해야 함



인터페이스

- 일종의 추상클래스
- 추상메서드와 상수만을 멤버로 가질 수 있음
* 1.8 부터 static 메서드와 default 메서드 포함 가능
- 다중상속 가능
- implements 로 구현 ex) class 클래스이름 implements 인터페이스 이름 { } 
- 인터페이스의 메서드중 일부만 구현하면 abstract 붙여서 추상클래스로 선언 해야함


인터페이스의 장점

- 개발시간을 단축시킬 수 있음
	: 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고 양쪽에서 동시에 개발을 진행할 수 있음

- 표준화가 가능
	: 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 일관되고 정형화된 프로그램의 개발이 가능

- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음
	: 상속관계에 있지 않아도 인터페이스를 공통적으로 구현하게 함으로써 관계를 맺어 줄 수 있음

- 독립적인 프로그래밍 가능
	: 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면 한 클래스의 변경이 다른 클래스에 영향을 미치지 않음 


인터페이스를 이용한 다형성

- 인터페이스 타입의 참조변수로 인터페이스를 구현한 클래스의 인스턴스를 참조 가능하며 인터페이스의 타입으로 형변환 가능
- 메서드의 매개변수의 타입으로도 사용 가능 




